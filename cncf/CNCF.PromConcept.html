<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/colorful.css">
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/style.css">
    <link rel="shortcut icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>Prom.Concept - Uxun's WIKI</title>
    <meta name="keywords" content=""/>
    <meta name="description" content=""/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
  </head>

  <body>
    <div id="container" class="typo">
      
<div id="header">
  <div id="post-nav">
    <a href="/wiki/">Uxun's WIKI</a>
    &nbsp;&#187;&nbsp;
    <a href="/wiki/#cncf">cncf</a>
    &nbsp;&#187;&nbsp;Prom.Concept
    <span class="updated">Page Updated&nbsp;
    
    </span>
  </div>
</div>
<div class="clearfix"></div>
<div id="content">
  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#prometheusconcept">Prometheus.Concept</a><ul>
<li><a href="#what-is-prometheus">What is Prometheus?</a></li>
<li><a href="#metric">Metric</a><ul>
<li><a href="#prom">Prom格式</a></li>
<li><a href="#prom_1">Prom分类</a></li>
<li><a href="#prom_2">Prom数据样本</a></li>
</ul>
</li>
<li><a href="#_1">数据采集</a></li>
<li><a href="#_2">数据处理</a></li>
<li><a href="#_3">数据存储</a><ul>
<li><a href="#localhost">localhost</a></li>
<li><a href="#remote-storage">remote storage</a></li>
</ul>
</li>
<li><a href="#alert">Alert</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="prometheusconcept">Prometheus.Concept</h1>
<h2 id="what-is-prometheus">What is Prometheus?</h2>
<p>Prometheus 由SoundCloud 开发的基于时序数据库开源监控告警系统，Google BorgMon监控系统的开源版本。Golang 开发，2016加入 CNCF。</p>
<p>只针对性能和可用性监控，不具备日志监控。</p>
<p><strong>特点：</strong></p>
<ol>
<li>多维度数据查询，tag关联组合，PromQL查询方式</li>
<li>支持本地存储，千万数据存储/秒，支持remote storage</li>
<li>基于HTTP的pull采集，push方式推送</li>
<li>动态发现机制</li>
<li>容器化部署</li>
</ol>
<p><strong>1.Metrics</strong></p>
<blockquote>
<p>指标获取方式：pull or push</p>
</blockquote>
<p><strong>Pull</strong></p>
<p>自动拉取监控指标数据，易扩展，降低藕合。采集端无需感知监控系统的存在，增强了系统的可控性。</p>
<p><strong>Push</strong></p>
<p>Prometheus提供了PushGateway的支持，监控指标主动推送到PushGateway，prometheus定时去拉</p>
<p><strong>2.Configuration</strong></p>
<blockquote>
<p>两种方式获取监控对象</p>
</blockquote>
<ol>
<li>通过配置文件进行静态配置</li>
<li>通过consul，zookeeper，kubernetes动态发现</li>
</ol>
<p><strong>3.Storage</strong></p>
<blockquote>
<p>两种存储方式</p>
</blockquote>
<ol>
<li>
<p>localhost</p>
<p>建议SSD，数据保存一个月</p>
</li>
<li>
<p>remote storage</p>
<p>remote write 和 remote read 接口实现，支持OpenTSDB，InfluxDB，Elasticsearch</p>
</li>
</ol>
<p><strong>4.AlertManager</strong></p>
<blockquote>
<p>独立于Prometheus组件</p>
</blockquote>
<p>设定预警规程，触发后，推送告警信息到AlertManager，可通过邮件，webhook，slack或者钉钉。</p>
<p>通过Gossip ，可在多个AlertManager直接同步告警msg。</p>
<p><strong>5.HA plan</strong></p>
<ol>
<li>Thanos (Improbable的prom高可用解决方案) </li>
</ol>
<h2 id="metric">Metric</h2>
<h3 id="prom">Prom格式</h3>
<p>监控指标定义统一格式：</p>
<div class="hlcode"><pre><span class="o">&lt;</span><span class="n">metric</span> <span class="n">name</span><span class="o">&gt;</span><span class="p">{</span><span class="o">&lt;</span><span class="n">lable</span> <span class="n">name</span><span class="o">&gt;=&lt;</span><span class="n">label</span> <span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">...}</span>
</pre></div>


<p>1.指标名称 <metric name></p>
<p>​   指标内容：HTTP请求总量http_request_total</p>
<p>2.标签<label></p>
<p>​   <lable name>=<lable value> 用于过滤和聚合，</p>
<p>​   e.g: {status="200", method="PUT"}，开头也可以是"__"，Prometheus 系统内部使用。</p>
<h3 id="prom_1">Prom分类</h3>
<p>prometheus指标分为四个类型</p>
<blockquote>
<p>Counter(计数器)，Gauge(仪表盘)，Histogram(直方图)，Summary(摘要)</p>
</blockquote>
<p>1.Counter</p>
<p>​   只增不减， 通常结合rate()方法获取指标某个时间段的变化率</p>
<p>2.Gauge</p>
<p>​   实时变化，可增可减，用量，监控数据基本都是Gauge类型</p>
<p>3.Histogram 和 Summary 用于凸显数据的分布情况，两种指标可以互相转化</p>
<p>​   监控样本数据需要满足以下条件</p>
<div class="hlcode"><pre><span class="c"># 指标必须提供 sum 和 count 方法，表示总和和总量；</span>
<span class="c"># Summary 类型符合 &quot;指标名称{quantile=分位点}&quot;格式</span>
<span class="c"># Histogram 类型符合 &quot;指标名称_bucket{le=分位点}&quot; 格式</span>
<span class="c"># 两类型 quantile 和 le 必须从小到大排序</span>
</pre></div>


<p><strong>Summary e.g:</strong></p>
<blockquote>
<p>分数位：0&lt;= x &lt;=1，分数位在n个观察值中按量x*n 排序的观测值。0.9分数位，表示90%位置上的数。</p>
</blockquote>
<div class="hlcode"><pre><span class="cp"># Prometheus Server中 WAL写入磁盘的同步时间</span>
<span class="n">Prometheu_tsdb_wal_fsync_duration_seconds</span><span class="p">{</span><span class="n">quantile</span><span class="o">=</span><span class="s">&quot;0.5&quot;</span><span class="p">}</span> <span class="mf">0.012345692</span>
<span class="n">Prometheu_tsdb_wal_fsync_duration_seconds</span><span class="p">{</span><span class="n">quantile</span><span class="o">=</span><span class="s">&quot;0.9&quot;</span><span class="p">}</span> <span class="mf">0.014436922</span>

<span class="cp"># 50%的同步时间低于0.012345692，90%的同步时间低于0.014436922</span>
</pre></div>


<p><strong>Histogram e.g:</strong></p>
<blockquote>
<p>区间的样本个数，通过{le=''}指定这个范围内的样本数。</p>
</blockquote>
<div class="hlcode"><pre><span class="cp"># 表示本地存储序列保存的chunk数量指标</span>
<span class="n">Prometheus_local_storage_series_chunks_persisted</span><span class="p">{</span><span class="n">le</span><span class="o">=</span><span class="s">&quot;1.6394e+06&quot;</span><span class="p">}</span> <span class="mi">260</span>
<span class="n">Prometheus_local_storage_series_chunks_persisted</span><span class="p">{</span><span class="n">le</span><span class="o">=</span><span class="s">&quot;6.5536e+06&quot;</span><span class="p">}</span> <span class="mi">780</span>

<span class="cp"># 小于1.6394e+06个chunks有260个，小于6.5536e+06个chunks有780个</span>
</pre></div>


<h3 id="prom_2">Prom数据样本</h3>
<p>样本数据已时间序列保存，三部分组成：指标，样本值，时间戳</p>
<div class="hlcode"><pre>series
  <span class="o">^</span>
  │   . . . . . . . . . . . . . . . . .   . .   <span class="p">{</span>__name__<span class="o">=</span><span class="s">&quot;request_total&quot;</span><span class="p">,</span>method<span class="o">=</span><span class="s">&quot;GET&quot;</span><span class="p">}</span>
  │     . . . . . . . . . . . . . . . . . . .   . . . .
  │     . . . . . . . . . .   . . . . . . . .    
  │     . . . . . . . . . . . . . . . .   . .  
  v
    <span class="o">&lt;------------------</span> time <span class="o">----------------&gt;</span> 
<span class="c1"># 纵轴：指标序列，横轴：时间。</span>
<span class="c1"># 每一行代表由一个指标组成的时间序列，每个点代表一个监控值。</span>
<span class="c1"># 时序数据先保存内存中，后批量刷新到磁盘。</span>
</pre></div>


<h2 id="_1">数据采集</h2>
<blockquote>
<p>Prometheus 对每个采集点分配一个线程，定时采集。</p>
<p># HELP: 帮助信息<br />
# TYPE:  metric类型</p>
</blockquote>
<p>两种方式： Pull 和 Push</p>
<p>1.Push </p>
<div class="hlcode"><pre><span class="c"># Push实时性优于 Pull，agent本地不保存数据，master需要维护agent状态</span>
<span class="c"># agent 决定上报的周期和内容</span>
<span class="c"># 每个agent需要配置master 地址</span>
</pre></div>


<p>2.Pull</p>
<div class="hlcode"><pre><span class="c"># Pull通常进行周期性采集(default: 30s)，agent本身需要一定的数据存储，master只负责数据拉取，masger可以为无状态。</span>
<span class="c"># master 控制采集内容和频率</span>
<span class="c"># 批量配置或者自动发现来获取所有采集点，可以充分与agent解藕，不用知晓master存在。</span>
</pre></div>


<p><strong>服务发现</strong></p>
<blockquote>
<p>静态配置文件 和 动态发现</p>
</blockquote>
<div class="hlcode"><pre><span class="cp"># 静态文件，采集192.168.1.12:9999 端口指标数据</span>
<span class="s">&quot;tragets&quot;</span><span class="o">:</span> <span class="p">[</span><span class="s">&quot;192.168.1.12:9999&quot;</span><span class="p">]</span> 

<span class="cp"># 动态发现，适用于云</span>
</pre></div>


<h2 id="_2">数据处理</h2>
<p>数据操作</p>
<blockquote>
<p>relabel, replace, keep, drop</p>
</blockquote>
<p>replace: 重新定义标签</p>
<p>keep: 保留需要的数据 (无用数据影响系统吞吐量，浪费空间)</p>
<p>drop: 丢弃匹配的标签数据</p>
<div class="hlcode"><pre><span class="cp"># Hash 取模</span>
<span class="nl">scrape_configs:</span>
 <span class="o">-</span> <span class="n">job_name</span><span class="o">:</span> <span class="n">some_job</span>
   <span class="nl">relabel_configs:</span>
   <span class="o">-</span> <span class="n">source_labels</span><span class="o">:</span> <span class="p">[</span><span class="n">__address__</span><span class="p">]</span>
     <span class="nl">modulus:</span> <span class="mi">4</span>   <span class="err">#</span> <span class="mi">4</span><span class="err">个采集点</span>
     <span class="nl">targeet_label:</span> <span class="n">__tmp_hash</span>
     <span class="nl">action:</span> <span class="n">hasmod</span>
   <span class="o">-</span> <span class="n">source_labels</span><span class="o">:</span> <span class="p">[</span><span class="n">__tmp_hash</span><span class="p">]</span>
     <span class="nl">regex:</span> <span class="o">^</span><span class="mi">1</span><span class="err">$</span>   <span class="err">#</span> <span class="err">匹配第</span><span class="mi">2</span><span class="err">个节点</span>
     <span class="nl">action:</span> <span class="n">keep</span>
</pre></div>


<h2 id="_3">数据存储</h2>
<p><strong>localhost and remote storage</strong></p>
<h3 id="localhost">localhost</h3>
<p>Prometheus 的本地存储称为Prometheus TSDB，TSDB的核心(block和WAL)</p>
<p><strong>block</strong></p>
<blockquote>
<p>block包含，chunks，index，meta.json，tombstones</p>
</blockquote>
<p>TSDB将存储的监控数据按照时间分隔成block，默认最小block保存2h监控数据。按照设置的步长倍数递增，步长为3，则：2h,6h,18h,将3个2h的block合并成一个6h的block，每个block都有一个全局唯一名称ULID</p>
<ol>
<li>chunks：保存压缩后的数据，大小为512MB，超过则截断多个chunk保持，数字编号命名</li>
<li>index：查询索引，记录chunk中时序的偏移位置(TOC表，符号表(Symbol Table)，时序列表(Series)，标签索引表(Label Index Table)，Postings表)</li>
<li>meta.json：block的元数据信息</li>
<li>tombstone：对一部份数据块进行删除(TSDB删除block数据块时候是对整个目录delete)</li>
</ol>
<p><strong>WAL</strong></p>
<blockquote>
<p>Write-ahead logging 预写日志：关系型数据库中利用日志来实行事物性和持久性的一种技术</p>
</blockquote>
<p>进行某个操作之前将事情记录下来，以便之后对数据进行回滚，重试等操作并保证数据的可靠性。</p>
<h3 id="remote-storage">remote storage</h3>
<p>对接远端存储及Adapter，首先需要进行压测，确保远端存储和Adapter都可以承受Prom的数据写入。单个Prom每秒可以采集1000万个指标项目。错误日志中出现Remote storage queue full，代表Adapter或者远端存储无法写入，并且开始丢弃部分监控数据。</p>
<p>推荐M3DB 对时序数据存储方面有良好的性能</p>
<p><strong>时序数据特点</strong></p>
<ol>
<li>相邻数据点时间戳的差值相对固定，即使变化，也在一个很小范围内浮动</li>
<li>相邻数据点的值的变化幅度很小，甚至无变化</li>
<li>对热数据的查询频率远远超出对非热点数据的查询频率，并且数据距离现在越近，热度越高</li>
</ol>
<p><strong>一种压缩算法</strong></p>
<blockquote>
<p>Gorilla 将16字节样本数据压缩到1.37字节，通过chunk保存</p>
</blockquote>
<p>原理：</p>
<div class="hlcode"><pre><span class="err">对时间戳采用两次去差值的方式，加入</span><span class="n">t0</span><span class="o">=</span><span class="mi">10</span><span class="o">:</span><span class="mo">00</span><span class="o">:</span><span class="mo">00</span><span class="p">,</span><span class="n">t1</span><span class="o">=</span><span class="mi">10</span><span class="o">:</span><span class="mo">01</span><span class="o">:</span><span class="mo">02</span><span class="err">和</span><span class="n">t2</span><span class="o">=</span><span class="mi">10</span><span class="o">:</span><span class="mo">02</span><span class="o">:</span><span class="mo">02</span> <span class="err">三个时间点。第一次压缩，</span><span class="n">t1</span><span class="o">-</span><span class="n">t0</span><span class="o">=</span><span class="mi">62</span><span class="p">,</span><span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="o">=</span><span class="mi">60</span><span class="p">;</span> <span class="err">第二次压缩时，</span><span class="mi">60</span><span class="o">-</span><span class="mi">62</span><span class="o">=-</span><span class="mi">2</span><span class="err">。采用差值的方式来大幅度降低存储空间，采样的频率通常也是固定的，这呀差值几乎都为</span><span class="mi">0</span><span class="err">。对于指标值，则对相邻指标进行异或</span><span class="p">(</span><span class="n">XOR</span><span class="p">)</span><span class="err">操作，如果前后两个采用值相等，二者异或的结果为</span><span class="mi">0</span><span class="err">，则只需保存一个</span><span class="mi">0</span><span class="err">，而且监控数据通常变化不大，异或结果将会很小，便于保存。</span>
</pre></div>


<p>v3版优点</p>
<blockquote>
<p>meta.json 元数据，index记录索引，每个block是一个目录</p>
</blockquote>
<ol>
<li>每个文件块最大支持512MB，避免SSD写放大</li>
<li>一段时间一个文件，避免时序流失</li>
<li>时间排序，可以将内存数据和磁盘数据合并，避免OOM</li>
<li>引入WAL，wal目录记录监控数据的WAL</li>
</ol>
<p><strong>Remote Storage</strong></p>
<p>adpter实现接口，将数据转化数据库各自协议</p>
<p><img alt="" src="https://prometheus.io/docs/prometheus/latest/images/remote_integrations.png" /></p>
<h2 id="alert">Alert</h2>
<p>promtheus本身不会对告警进行处理，需要借助另一个组件AlertManager。</p>
<p><a href="https://github.com/prometheus/alertmanager#high-availability">AlertManager</a>分两部分：router and receiver </p>
<blockquote>
<p>告警信息经过路由树，然后分配对应的接收器中</p>
</blockquote>
<p><img alt="" src="https://github.com/prometheus/alertmanager/raw/master/doc/arch.svg?sanitize=true" /></p>
<p><strong>work flow</strong></p>
<p>prom 调用 alertmanager 接口，alertmanager保存到各自provider里，provider提供一个订阅接口(subscribe)，这样Dispatcher组件可以获取告警数据。</p>
<p>Gossip(解决多个AlertManager重复发送报警问题)，是一种最终一致性协议，负责两处信息同步：</p>
<div class="hlcode"><pre><span class="mf">1.</span><span class="err">保证每个</span><span class="n">AlertManager</span><span class="err">之间静默配置一致，保证每个</span><span class="n">AlertManager</span><span class="err">都能报警。</span>
<span class="mf">2.</span><span class="err">告警在每个</span><span class="n">AlertManager</span><span class="err">之间同步，相同告警去重</span><span class="p">(</span><span class="n">Dedup</span><span class="p">)</span><span class="err">。</span>
<span class="err">问题：告警同时发出，没等到</span><span class="n">Gossip</span><span class="err">同步？</span>
    <span class="err">加入</span><span class="p">(</span><span class="n">Wait</span><span class="p">)</span><span class="err">机制，每个节点的</span><span class="n">Wait</span><span class="err">时间调整到不同的时间，</span><span class="n">e</span><span class="p">.</span><span class="n">g</span> <span class="n">node1</span><span class="o">:</span><span class="mi">0</span><span class="n">s</span><span class="p">,</span><span class="n">node2</span><span class="o">:</span><span class="mi">5</span><span class="n">s</span>
</pre></div>
  
</div>
    </div>
    <div id="footer">
      <div class="footer-left">
        <p>
        Copyright © 2019 Uxun.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
        Theme by <a href="https://github.com/tankywoo/yasimple_x2" target="_blank">YASimple_X2</a>.
        </p>
      </div> <!-- end footer-left -->
      <div class="footer-right">
        <p>Page Updated 2019-09-28 21:55:11</p>
      </div> <!-- end footer-right -->
    </div>

    
    

  </body>
</html>